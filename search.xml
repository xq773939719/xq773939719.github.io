<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="我的第一篇博客文章"><a href="#我的第一篇博客文章" class="headerlink" title="我的第一篇博客文章"></a>我的第一篇博客文章</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote>
<p>这是一个测试</p>
</blockquote>
<h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><blockquote>
<p>这是一个测试</p>
</blockquote>
<h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h2><blockquote>
<p>这是一个测试</p>
</blockquote>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2>]]></content>
  </entry>
  <entry>
    <title>[重学技术]NSObject</title>
    <url>/posts/%E9%87%8D%E5%AD%A6%E6%8A%80%E6%9C%AF-NSObject/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote>
<p>[重学技术]系列主要是针对笔者自己的能力进行的针对性学习，不代表广大读者的情况。</p>
</blockquote>
<h2 id="带着问题出发"><a href="#带着问题出发" class="headerlink" title="带着问题出发"></a>带着问题出发</h2><ul>
<li>什么是NSObject</li>
<li>NSObject的本质</li>
</ul>
<h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h2 id="1-以代码开始"><a href="#1-以代码开始" class="headerlink" title="1.以代码开始"></a>1.以代码开始</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *p = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%p, %p, %@, %@, %@, %@&quot;</span>, p, &amp;p, @(<span class="keyword">sizeof</span>(p)), @(<span class="keyword">sizeof</span>(&amp;p)), @(<span class="keyword">sizeof</span>(p.class)), @(<span class="keyword">sizeof</span>(<span class="built_in">NSObject</span>.class)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ooutput: 0x6000023c0050, 0x16d7dea08, 8, 8, 8, 8</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里可以看出p指针指向一块内存区域，&amp;p即是NSObject的一个实例对象的所在的地址。</p>
</blockquote>
<h2 id="2-一行指令"><a href="#2-一行指令" class="headerlink" title="2.一行指令"></a>2.一行指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc &#123;源文件&#125; [-o] [&#123;目标文件&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="3-三段代码"><a href="#3-三段代码" class="headerlink" title="3.三段代码"></a>3.三段代码</h2><h3 id="1-主函数"><a href="#1-主函数" class="headerlink" title="1.主函数"></a>1.主函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Foundation头文件展开的部分 超多行</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* @autoreleasepool */</span> </span><br><span class="line">    &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        NSObject *p = ((NSObject *(*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)(</span><br><span class="line">                (id)((NSObject *(*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)(</span><br><span class="line">                    (id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSObject&quot;</span>), </span><br><span class="line">                    <span class="built_in">sel_registerName</span>(<span class="string">&quot;alloc&quot;</span>)</span><br><span class="line">                ), </span><br><span class="line">                <span class="built_in">sel_registerName</span>(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">            );</span><br><span class="line">        <span class="built_in">NSLog</span>(</span><br><span class="line">            (NSString *)&amp;__NSConstantStringImpl__var_folders_4d_7c_zjhjd1wz9xbn__txr1fcm0000gn_T_Untitled_f321d2_mi_0, </span><br><span class="line">            p,</span><br><span class="line">            &amp;p, </span><br><span class="line">            ((NSNumber *(*)(Class, SEL, <span class="type">unsigned</span> <span class="type">long</span>))(<span class="type">void</span> *)objc_msgSend)(<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSNumber&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;numberWithUnsignedLong:&quot;</span>),(<span class="built_in">sizeof</span> (p))),</span><br><span class="line">            ((NSNumber *(*)(Class, SEL, <span class="type">unsigned</span> <span class="type">long</span>))(<span class="type">void</span> *)objc_msgSend)(<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSNumber&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;numberWithUnsignedLong:&quot;</span>), (<span class="built_in">sizeof</span> (&amp;p))),</span><br><span class="line">            ((NSNumber *(*)(Class, SEL, <span class="type">unsigned</span> <span class="type">long</span>))(<span class="type">void</span> *)objc_msgSend)(<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSNumber&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;numberWithUnsignedLong:&quot;</span>), </span><br><span class="line">            (<span class="built_in">sizeof</span> ((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)p, <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>)))), </span><br><span class="line">            ((NSNumber *(*)(Class, SEL, <span class="type">unsigned</span> <span class="type">long</span>))(<span class="type">void</span> *)objc_msgSend)(<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSNumber&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;numberWithUnsignedLong:&quot;</span>), </span><br><span class="line">            (<span class="built_in">sizeof</span> ((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSObject&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>))))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="2-需要关注的部分"><a href="#2-需要关注的部分" class="headerlink" title="2.需要关注的部分"></a>2.需要关注的部分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> NSObject; <span class="comment">// NSObject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NSObject_IMPL</span> &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class; <span class="comment">// Class</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id; <span class="comment">// id</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_selector</span> *SEL; <span class="comment">// SEL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">// IMP</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> BOOL; <span class="comment">// BOOL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>NSObject_IMPL &#x3D;&#x3D; NSObject 一个实例对应的结构，所有实例对象的操作都是通过isa指针操作<br>类对象 + 元类对象 &#x3D; NSObject</p>
</blockquote>
<h3 id="3-关键方法"><a href="#3-关键方法" class="headerlink" title="3.关键方法"></a>3.关键方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_msgSend</span>(id, SEL)</span><br><span class="line"><span class="built_in">objc_getClass</span>(<span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line"><span class="built_in">sel_registerName</span>(<span class="type">const</span> <span class="type">char</span> *name)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>拆分结构后比较清晰，它们分别完成一些任务<br>    - objc_msgSend(id, SEL, …) 负责消息发送，传入接收方、方法、参数。<br>    - objc_getClass(const char *name) 负责通过类名获取类对象<br>    - sel_registerName(const char *name) 负责通过方法名拿到方法</p>
</blockquote>
<h2 id="4-分析"><a href="#4-分析" class="headerlink" title="4.分析"></a>4.分析</h2><h3 id="1-NSObject"><a href="#1-NSObject" class="headerlink" title="1.NSObject"></a>1.NSObject</h3><p>从源码的<code>NSObject.h</code>,<code>NSObject.mm</code>,<code>objc-object.h</code>,<code>objc-private.h</code>,<code>objc-runtime-new.h</code>看，关键是<code>_objc_</code>, <code>object_</code>, <code>class_</code>开头的核心方法以及内部的结构体|类:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象本身</span></span><br><span class="line">+ (<span class="type">id</span>)<span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象本身</span></span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类对象</span></span><br><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，获取实例的，类对象</span></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，获取当前类的，父类对象</span></span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，获取当前实例的，父类对象</span></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>]-&gt;getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是不是cls</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，判断当前实例，是不是cls的实例</span></span><br><span class="line">- (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是不是cls的子类对象</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，判断当前实例，是不是cls的子类对象的实例</span></span><br><span class="line">- (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123; </span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是不是cls的子类对象</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isSubclassOfClass:(Class)cls &#123; </span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是不是obj的父类对象</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isAncestorOfObject:(<span class="built_in">NSObject</span> *)obj &#123; </span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [obj <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == <span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法 (实例 方法 相应的类对象)</span></span><br><span class="line">+ (<span class="type">BOOL</span>)instancesRespondToSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> class_respondsToSelector_inst(<span class="literal">nil</span>, sel, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法 (实例 方法 相应的类对象)</span></span><br><span class="line">+ (<span class="type">BOOL</span>)respondsToSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> class_respondsToSelector_inst(<span class="keyword">self</span>, sel, <span class="keyword">self</span>-&gt;ISA());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法 (实例 方法 相应的类对象)</span></span><br><span class="line">- (<span class="type">BOOL</span>)respondsToSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> class_respondsToSelector_inst(<span class="keyword">self</span>, sel, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是否遵循某个协议</span></span><br><span class="line">+ (<span class="type">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="keyword">if</span> (!protocol) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (class_conformsToProtocol(tcls, protocol)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前实例，是否遵循某个协议</span></span><br><span class="line">- (<span class="type">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="keyword">if</span> (!protocol) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (class_conformsToProtocol(tcls, protocol)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象哈希</span></span><br><span class="line">+ (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootHash(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例哈希</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootHash(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象是否相等(指针维度)</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isEqual:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">return</span> obj == (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例是否相等(指针维度)</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqual:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ??? override point</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isFault &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ??? override point</span></span><br><span class="line">- (<span class="type">BOOL</span>)isFault &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否代理 override point</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isProxy &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否代理 override point</span></span><br><span class="line">- (<span class="type">BOOL</span>)isProxy &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，SEL -&gt; IMP 查询</span></span><br><span class="line">+ (IMP)instanceMethodForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> class_getMethodImplementation(<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于object_getMethodImplementation包装了class_getMethodImplementation</span></span><br><span class="line">IMP object_getMethodImplementation(<span class="type">id</span> obj, SEL name) &#123;</span><br><span class="line">    Class cls = (obj ? obj-&gt;getIsa() : <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">return</span> class_getMethodImplementation(cls, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，SEL -&gt; IMP 查询</span></span><br><span class="line">+ (IMP)methodForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> object_getMethodImplementation((<span class="type">id</span>)<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，SEL -&gt; IMP 查询</span></span><br><span class="line">- (IMP)methodForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> object_getMethodImplementation(<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第一环 当前对象处理</span></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第一环 当前对象处理</span></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析最终崩溃点</span></span><br><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">+ (<span class="type">void</span>)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[%s %s]: unrecognized selector sent to instance %p&quot;</span>, </span><br><span class="line">                class_getName(<span class="keyword">self</span>), sel_getName(sel), <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析最终崩溃点</span></span><br><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">- (<span class="type">void</span>)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;</span>, </span><br><span class="line">                object_getClassName(<span class="keyword">self</span>), sel_getName(sel), <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态调用类方法</span></span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel, obj);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj1 withObject:(<span class="type">id</span>)obj2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>, <span class="type">id</span>))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel, obj1, obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态调用实例方法</span></span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL))objc_msgSend)(<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj1 withObject:(<span class="type">id</span>)obj2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>, <span class="type">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj1, obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第三环 签名</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[NSObject instanceMethodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第三环 签名</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;-[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第三环 完整消息转发</span></span><br><span class="line">+ (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第三环 完整消息转发</span></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第二环 快速消息转发 转发给另一个对象</span></span><br><span class="line">+ (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第二环 快速消息转发 转发给另一个对象</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象描述 override point</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSString)</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)debugDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> description];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象描述 override point</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSString)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)debugDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> description];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.对象的出生</span></span><br><span class="line">+ (<span class="type">id</span>)new &#123;</span><br><span class="line">    <span class="keyword">return</span> [callAlloc(<span class="keyword">self</span>, <span class="literal">false</span><span class="comment">/*checkNil*/</span>) init];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">+ (<span class="type">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAllocWithZone(<span class="keyword">self</span>, (objc_zone_t)zone);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">+ (<span class="type">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.引用计数</span></span><br><span class="line">+ (<span class="type">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">BOOL</span>)_tryRetain &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ULONG_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootRetain(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="type">BOOL</span>)_tryRetain &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootTryRetain(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootRetainCount(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">+ (<span class="type">BOOL</span>)allowsWeakReference &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>; </span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">BOOL</span>)retainWeakReference &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>; </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)allowsWeakReference &#123; </span><br><span class="line">    <span class="keyword">return</span> ! [<span class="keyword">self</span> _isDeallocating]; </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)retainWeakReference &#123; </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> _tryRetain]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.存活空间</span></span><br><span class="line">+ (<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> _NSZone *)_objc_rootZone(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> _NSZone *)_objc_rootZone(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.续命</span></span><br><span class="line">+ (<span class="type">id</span>)<span class="keyword">copy</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)copyWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">copy</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">id</span>)<span class="keyword">self</span> copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)mutableCopy &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)mutableCopyWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)mutableCopy &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">id</span>)<span class="keyword">self</span> mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.对象的消亡</span></span><br><span class="line">+ (<span class="type">id</span>)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="type">id</span>)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAutorelease(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">oneway</span> <span class="type">void</span>)release &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="keyword">oneway</span> <span class="type">void</span>)release &#123;</span><br><span class="line">    _objc_rootRelease(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">+ (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by NSZombies</span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">BOOL</span>)_isDeallocating &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)_isDeallocating &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootIsDeallocating(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Previously used by GC. Now a placeholder for binary compatibility.</span></span><br><span class="line">- (<span class="type">void</span>) finalize &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-objc-object"><a href="#2-objc-object" class="headerlink" title="2.objc_object"></a>2.objc_object</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> isa_storage[<span class="built_in">sizeof</span>(<span class="type">isa_t</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">isa_t</span> &amp;<span class="title">isa</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">isa_t</span> *&gt;(isa_storage); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">isa_t</span> &amp;<span class="title">isa</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">isa_t</span> *&gt;(isa_storage); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">(<span class="type">bool</span> authenticated = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA</span></span><br><span class="line">    <span class="function">Class <span class="title">rawISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">isaBits</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initIsa() should be used to init the isa of new objects only.</span></span><br><span class="line">    <span class="comment">// If this object already has an isa, use changeIsa() for correctness.</span></span><br><span class="line">    <span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></span><br><span class="line">    <span class="comment">// initClassIsa(): class objects</span></span><br><span class="line">    <span class="comment">// initProtocolIsa(): protocol objects</span></span><br><span class="line">    <span class="comment">// initIsa(): other objects</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=false*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initClassIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=maybe*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initProtocolIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=maybe*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initInstanceIsa</span><span class="params">(Class cls, <span class="type">bool</span> hasCxxDtor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// changeIsa() should be used to change the isa of existing objects.</span></span><br><span class="line">    <span class="comment">// If this is a new object, use initIsa() for performance.</span></span><br><span class="line">    <span class="function">Class <span class="title">changeIsa</span><span class="params">(Class newCls)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNonpointerIsa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaggedPointer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBasicTaggedPointer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isExtTaggedPointer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object may have associated objects?</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAssociatedObjects</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHasAssociatedObjects</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object may be weakly referenced?</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWeaklyReferenced</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWeaklyReferenced_nolock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object may be uniquely referenced?</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUniquelyReferenced</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object may have -.cxx_destruct implementation?</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCxxDtor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimized calls to retain/release methods</span></span><br><span class="line">    <span class="function">id <span class="title">retain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">autorelease</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implementations of retain/release methods</span></span><br><span class="line">    <span class="function">id <span class="title">rootRetain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rootRelease</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">rootAutorelease</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rootTryRetain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rootReleaseShouldDealloc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">rootRetainCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implementation of dealloc methods</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rootIsDeallocating</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearDeallocating</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rootDealloc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initIsa</span><span class="params">(Class newCls, <span class="type">bool</span> nonpointer, <span class="type">bool</span> hasCxxDtor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slow paths for inline control</span></span><br><span class="line">    <span class="function">id <span class="title">rootAutorelease2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="comment">// Controls what parts of root&#123;Retain,Release&#125; to emit/inline</span></span><br><span class="line">    <span class="comment">// - Full means the full (slow) implementation</span></span><br><span class="line">    <span class="comment">// - Fast means the fastpaths only</span></span><br><span class="line">    <span class="comment">// - FastOrMsgSend means the fastpaths but checking whether we should call</span></span><br><span class="line">    <span class="comment">//   -retain/-release or Swift, for the usage of objc_&#123;retain,release&#125;</span></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">RRVariant</span> &#123;</span><br><span class="line">        Full,</span><br><span class="line">        Fast,</span><br><span class="line">        FastOrMsgSend,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unified retain count manipulation for nonpointer isa</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> id <span class="title">rootRetain</span><span class="params">(<span class="type">bool</span> tryRetain, RRVariant variant)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">rootRelease</span><span class="params">(<span class="type">bool</span> performDealloc, RRVariant variant)</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">rootRetain_overflow</span><span class="params">(<span class="type">bool</span> tryRetain)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">rootRelease_underflow</span><span class="params">(<span class="type">bool</span> performDealloc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearDeallocating_slow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Side table retain count overflow for nonpointer isa</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SidetableBorrow</span> &#123; <span class="type">size_t</span> borrowed, remaining; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_moveExtraRC_nolock</span><span class="params">(<span class="type">size_t</span> extra_rc, <span class="type">bool</span> isDeallocating, <span class="type">bool</span> weaklyReferenced)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_addExtraRC_nolock</span><span class="params">(<span class="type">size_t</span> delta_rc)</span></span>;</span><br><span class="line">    <span class="function">SidetableBorrow <span class="title">sidetable_subExtraRC_nolock</span><span class="params">(<span class="type">size_t</span> delta_rc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">sidetable_getExtraRC_nolock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_clearExtraRC_nolock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Side-table-only retain count</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_isDeallocating</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_clearDeallocating</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_isWeaklyReferenced</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_setWeaklyReferenced_nolock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">id <span class="title">sidetable_retain</span><span class="params">(<span class="type">bool</span> locked = <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">sidetable_retain_slow</span><span class="params">(SideTable&amp; table)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">sidetable_release</span><span class="params">(<span class="type">bool</span> locked = <span class="literal">false</span>, <span class="type">bool</span> performDealloc = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">sidetable_release_slow</span><span class="params">(SideTable&amp; table, <span class="type">bool</span> performDealloc = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_tryRetain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">sidetable_retainCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_present</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performDealloc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-objc-class-objc-object"><a href="#3-objc-class-objc-object" class="headerlink" title="3.objc_class: objc_object"></a>3.objc_class: objc_object</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="built_in">objc_class</span>(<span class="type">const</span> objc_class&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">objc_class</span>(objc_class&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> objc_class&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(objc_class&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Class <span class="title">getSuperclass</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> ISA_SIGNING_AUTH_MODE == ISA_SIGNING_AUTH</span></span><br><span class="line">        <span class="keyword">if</span> (superclass == Nil)</span><br><span class="line">            <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPERCLASS_SIGNING_TREAT_UNSIGNED_AS_NIL</span></span><br><span class="line">        <span class="type">void</span> *stripped = <span class="built_in">ptrauth_strip</span>((<span class="type">void</span> *)superclass, ISA_SIGNING_KEY);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">void</span> *)superclass == stripped) &#123;</span><br><span class="line">            <span class="type">void</span> *resigned = <span class="built_in">ptrauth_sign_unauthenticated</span>(stripped, ISA_SIGNING_KEY, <span class="built_in">ptrauth_blend_discriminator</span>(&amp;superclass, ISA_SIGNING_DISCRIMINATOR_CLASS_SUPERCLASS));</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span> *)superclass != resigned)</span><br><span class="line">                <span class="keyword">return</span> Nil;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *result = <span class="built_in">ptrauth_auth_data</span>((<span class="type">void</span> *)superclass, ISA_SIGNING_KEY, <span class="built_in">ptrauth_blend_discriminator</span>(&amp;superclass, ISA_SIGNING_DISCRIMINATOR_CLASS_SUPERCLASS));</span><br><span class="line">        <span class="keyword">return</span> (Class)result;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> (Class)<span class="built_in">ptrauth_strip</span>((<span class="type">void</span> *)superclass, ISA_SIGNING_KEY);</span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> superclass;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuperclass</span><span class="params">(Class newSuperclass)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ISA_SIGNING_SIGN_MODE == ISA_SIGNING_SIGN_ALL</span></span><br><span class="line">        superclass = (Class)<span class="built_in">ptrauth_sign_unauthenticated</span>((<span class="type">void</span> *)newSuperclass, ISA_SIGNING_KEY, <span class="built_in">ptrauth_blend_discriminator</span>(&amp;superclass, ISA_SIGNING_DISCRIMINATOR_CLASS_SUPERCLASS));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        superclass = newSuperclass;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setData</span>(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">class_ro_t</span> *<span class="title">safe_ro</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInfo</span><span class="params">(<span class="type">uint32_t</span> set)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">data</span>()-&gt;<span class="built_in">setFlags</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearInfo</span><span class="params">(<span class="type">uint32_t</span> clear)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">data</span>()-&gt;<span class="built_in">clearFlags</span>(clear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set and clear must not overlap</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeInfo</span><span class="params">(<span class="type">uint32_t</span> set, <span class="type">uint32_t</span> clear)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">ASSERT</span>((set &amp; clear) == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">data</span>()-&gt;<span class="built_in">changeFlags</span>(set, clear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAllocNonpointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(!<span class="built_in">isFuture</span>());</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">instancesRequireRawIsa</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSwiftStable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">isSwiftStable</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSwiftLegacy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">isSwiftLegacy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnySwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">isAnySwift</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSwiftStable_ButAllowLegacyForNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">isSwiftStable_ButAllowLegacyForNow</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">swiftClassFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint32_t</span> *)(&amp;bits + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">usesSwiftRefcounting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isSwiftStable</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">swiftClassFlags</span>() &amp; <span class="number">2</span>); <span class="comment">//ClassFlags::UsesSwiftRefcounting</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCallSwiftRR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// !hasCustomCore() is being used as a proxy for isInitialized(). All</span></span><br><span class="line">        <span class="comment">// classes with Swift refcounting are !hasCustomCore() (unless there are</span></span><br><span class="line">        <span class="comment">// category or swizzling shenanigans), but that bit is not set until a</span></span><br><span class="line">        <span class="comment">// class is initialized. Checking isInitialized requires an extra</span></span><br><span class="line">        <span class="comment">// indirection that we want to avoid on RR fast paths.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// In the unlikely event that someone causes a class with Swift</span></span><br><span class="line">        <span class="comment">// refcounting to be hasCustomCore(), we&#x27;ll fall back to sending -retain</span></span><br><span class="line">        <span class="comment">// or -release, which is still correct.</span></span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">hasCustomCore</span>() &amp;&amp; <span class="built_in">usesSwiftRefcounting</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStubClass</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">uintptr_t</span> isa = (<span class="type">uintptr_t</span>)<span class="built_in">isaBits</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;= isa &amp;&amp; isa &lt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swift stable ABI built for old deployment targets looks weird.</span></span><br><span class="line">    <span class="comment">// The is-legacy bit is set for compatibility with old libobjc.</span></span><br><span class="line">    <span class="comment">// We are on a &quot;new&quot; deployment target so we need to rewrite that bit.</span></span><br><span class="line">    <span class="comment">// These stable-with-legacy-bit classes are distinguished from real</span></span><br><span class="line">    <span class="comment">// legacy classes using another bit in the Swift data</span></span><br><span class="line">    <span class="comment">// (ClassFlags::IsSwiftPreStableABI)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnfixedBackwardDeployingStableSwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Only classes marked as Swift legacy need apply.</span></span><br><span class="line">        <span class="keyword">if</span> (!bits.<span class="built_in">isSwiftLegacy</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the true legacy vs stable distinguisher.</span></span><br><span class="line">        <span class="comment">// The low bit of Swift&#x27;s ClassFlags is SET for true legacy</span></span><br><span class="line">        <span class="comment">// and UNSET for stable pretending to be legacy.</span></span><br><span class="line">        <span class="type">bool</span> isActuallySwiftLegacy = <span class="built_in">bool</span>(<span class="built_in">swiftClassFlags</span>() &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> !isActuallySwiftLegacy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fixupBackwardDeployingStableSwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isUnfixedBackwardDeployingStableSwift</span>()) &#123;</span><br><span class="line">            <span class="comment">// Class really is stable Swift, pretending to be pre-stable.</span></span><br><span class="line">            <span class="comment">// Fix its lie.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// N.B. At this point, bits is *always* a class_ro pointer; we</span></span><br><span class="line">            <span class="comment">// can&#x27;t use setIsSwiftStable() because that only works for a</span></span><br><span class="line">            <span class="comment">// class_rw pointer.</span></span><br><span class="line">            bits.<span class="built_in">setIsSwiftStableRO</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_objc_swiftMetadataInitializer <span class="title">swiftMetadataInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">swiftMetadataInitializer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return YES if the class&#x27;s ivars are managed by ARC,</span></span><br><span class="line">    <span class="comment">// or the class is MRC but has ARC-style weak ivars.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAutomaticIvars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;flags &amp; (RO_IS_ARC | RO_HAS_WEAK_WITHOUT_ARC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return YES if the class&#x27;s ivars are managed by ARC.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isARC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;flags &amp; RO_IS_ARC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">forbidsAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">data</span>()-&gt;flags &amp; RW_FORBIDS_ASSOCIATED_OBJECTS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="comment">// Tracked in non-pointer isas; not tracked otherwise</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">instancesHaveAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this may be an unrealized future class in the CF-bridged case</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInstancesHaveAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this may be an unrealized future class in the CF-bridged case</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">setInfo</span>(RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">shouldGrowCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setShouldGrowCache</span><span class="params">(<span class="type">bool</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fixme good or bad for memory use?</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;bits.<span class="built_in">flags</span>() &amp; RW_INITIALIZING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">        <span class="built_in">ISA</span>()-&gt;<span class="built_in">setInfo</span>(RW_INITIALIZING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;bits.<span class="built_in">flags</span>() &amp; RW_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInitialized</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLoadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// any class registered for +load is definitely loadable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IMP <span class="title">getLoadMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Locking: To prevent concurrent realization, hold runtimeLock.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRealized</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">isStubClass</span>() &amp;&amp; (bits.<span class="built_in">flags</span>() &amp; RW_REALIZED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if this is an unrealized future class.</span></span><br><span class="line">    <span class="comment">// Locking: To prevent concurrent realization, hold runtimeLock.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFuture</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isStubClass</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">flags</span>() &amp; RW_FUTURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ASSERT_THIS_NOT_NULL;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FAST_CACHE_META</span></span><br><span class="line">        <span class="keyword">return</span> cache.<span class="built_in">getBit</span>(FAST_CACHE_META);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_META;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Like isMetaClass, but also valid on un-realized classes</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMetaClassMaybeUnrealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(<span class="built_in">offsetof</span>(<span class="type">class_rw_t</span>, flags) == <span class="built_in">offsetof</span>(<span class="type">class_ro_t</span>, flags), <span class="string">&quot;flags alias&quot;</span>);</span><br><span class="line">        <span class="built_in">static_assert</span>(RO_META == RW_META, <span class="string">&quot;flags alias&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isStubClass</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">flags</span>() &amp; RW_META;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NOT identical to this-&gt;ISA when this is a metaclass</span></span><br><span class="line">    <span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isMetaClassMaybeUnrealized</span>()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRootClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSuperclass</span>() == nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRootMetaclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ISA</span>() == (Class)<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this class does not have a name already, we can ask Swift to construct one for us.</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">installMangledNameForLazilyNamedClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the class&#x27;s mangled name, or NULL if the class has a lazy</span></span><br><span class="line">    <span class="comment">// name that hasn&#x27;t been created yet.</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">nonlazyMangledName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>()-&gt;<span class="built_in">getName</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">mangledName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fixme can&#x27;t assert locks here</span></span><br><span class="line">        ASSERT_THIS_NOT_NULL;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *result = <span class="built_in">nonlazyMangledName</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="comment">// This class lazily instantiates its name. Emplace and</span></span><br><span class="line">            <span class="comment">// return it.</span></span><br><span class="line">            result = <span class="built_in">installMangledNameForLazilyNamedClass</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the class&#x27;s mangled name, or NULL if it has a lazy name that hasn&#x27;t</span></span><br><span class="line">    <span class="comment">// been created yet, WITHOUT authenticating the signed class_ro pointer.</span></span><br><span class="line">    <span class="comment">// This exists sosely for objc_debug_class_getNameRaw to use.</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">rawUnsafeMangledName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Strip the class_ro pointer instead of authenticating so that we can</span></span><br><span class="line">        <span class="comment">// handle classes without signed class_ro pointers in the shared cache</span></span><br><span class="line">        <span class="comment">// even if they haven&#x27;t been officially loaded yet. rdar://90415774</span></span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>&lt;Authentication::Strip&gt;()-&gt;<span class="built_in">getName</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">demangledName</span><span class="params">(<span class="type">bool</span> needsLock)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">nameForLogging</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// May be unaligned depending on class&#x27;s ivars.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">unalignedInstanceStart</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;instanceStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class&#x27;s instance start rounded up to a pointer-size boundary.</span></span><br><span class="line">    <span class="comment">// This is used for ARC layout bitmaps.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">alignedInstanceStart</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceStart</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// May be unaligned depending on class&#x27;s ivars.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">unalignedInstanceSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;instanceSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceSize</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="type">size_t</span> extraBytes)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fastpath</span>(cache.<span class="built_in">hasFastInstanceSize</span>(extraBytes))) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.<span class="built_in">fastInstanceSize</span>(extraBytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> size = <span class="built_in">alignedInstanceSize</span>() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInstanceSize</span><span class="params">(<span class="type">uint32_t</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">data</span>()-&gt;flags &amp; RW_REALIZING);</span><br><span class="line">        <span class="keyword">auto</span> ro = <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>();</span><br><span class="line">        <span class="keyword">if</span> (newSize != ro-&gt;instanceSize) &#123;</span><br><span class="line">            <span class="built_in">ASSERT</span>(<span class="built_in">data</span>()-&gt;flags &amp; RW_COPIED_RO);</span><br><span class="line">            *<span class="built_in">const_cast</span>&lt;<span class="type">uint32_t</span> *&gt;(&amp;ro-&gt;instanceSize) = newSize;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">setFastInstanceSize</span>(newSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chooseClassArrayIndex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setClassArrayIndex</span><span class="params">(<span class="type">unsigned</span> Idx)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setClassArrayIndex</span>(Idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">classArrayIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">classArrayIndex</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-其他结构"><a href="#4-其他结构" class="headerlink" title="4.其他结构"></a>4.其他结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">preopt_cache_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RelativePointer</span>: <span class="type">nocopy_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stub_class_t</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">method_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ivar_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">property_t</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">entsize_list_tt</span> &#123;&#125; <span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">method_list_t</span>: entsize_list_tt &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">protocol_t</span> : objc_object &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">protocol_list_t</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_data_bits_t</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list_array_tt</span> &#123;&#125; <span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">method_array_t</span>: list_array_tt &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">property_array_t</span>: list_array_tt &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">protocol_array_t</span>: list_array_tt &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">swift_class_t</span>: objc_class &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">category_t</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-一切皆对象"><a href="#5-一切皆对象" class="headerlink" title="5.一切皆对象"></a>5.<code>一切皆对象</code></h3><p>从源码可以看到objc_class继承自objc_object，从而具有了对象的能力。<br>可以看到NSObject_IMPL中isa作为Class类型，本质上指向了自己对应的objc_class类型的类对象。<br>同时objc_class中isa作为Class类型，指向了类对象所对应的元类对象。</p>
<blockquote>
<p>instance.isa -n-&gt; 类对象.isa -1-&gt; 元类对象.isa -&gt; 根元类对象。<br>从设计者角度来看，类对象会占用空间，但是不需要存储多份，<code>把变化的部分(状态：实例变量)外置，运行时存储到堆栈；而不变的部分(行为：实例方法)内置</code>，所以可以认为类对象为实例提供了<code>原型</code>，通过isa连接。<br>元类对象同样会占用空间，同样不需要存储多份，<code>把变化的部分(状态：类变量)外置，运行时存储到全局区域；而不变的部分(行为：类方法)内置</code>，同样认为元类对象为类对象提供了<code>原型</code>，通过isa连接。</p>
</blockquote>
<pre><code class="c++">
# 3. 结语

# 4. 参考
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>NSObject</tag>
      </tags>
  </entry>
  <entry>
    <title>[重学技术]序章</title>
    <url>/posts/%E9%87%8D%E5%AD%A6%E6%8A%80%E6%9C%AF-%E5%BA%8F%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote>
<p>[重学技术]系列主要是针对笔者自己的能力进行的针对性学习，不代表广大读者的情况。</p>
</blockquote>
<h1 id="2-为什么开始"><a href="#2-为什么开始" class="headerlink" title="2.为什么开始"></a>2.为什么开始</h1><p>自2021年至今，真正做iOS方面的开发已经有两年有余了，但是作为移动端开发者，我把太多的时间精力关注代码质量和琐碎的业务事情上，始终没能一窥底层的面貌，对底层的理解也一直停留在了初级阶段，没有深入到底层的实现细节。我慢慢的发现，我只会在应用层实现需求。</p>
<p>总结有几点原因：其一，没有养成探索意识，觉得实现需求就够了，但事实上只完成需求远远不够。业务开发大部分是在和产品的业务逻辑、数据展现、修复Bug和用户体验等打交道，这些都需要花费大量的时间精力，以至于没时间思考，没精力探索。其二，懒于学习，不愿意花时间去学习，而是把精力放在了业务的开发上，成为了无情的<code>需求实现机</code>。其三，没有把技术的学习当作一种乐趣，而是把技术的学习当作一种痛苦，因为技术的学习是一件痛苦的事。</p>
<p>我意识到这种情况已经有一年了，但是琐事缠身或者懒癌晚期，拖到现在。人无远虑必有近忧，这话是真没错，偶然的机会开始看看外面的机会，顺便检验下自己能力。很显然结果不太好，一些基础通过复习下可以理解的还👌🏻，但是深入下去，就突然尬住，不知道该说什么。还有些问题没接触过很难回答完美，我承认是自己背诵不到位，是我菜~。所以经过几天的思考，我希望能再之后的时间提升自己的技术能力，深入底层技术，把自己训练成一个<code>技术爱好者</code>，而不是一个<code>需求实现机</code>。</p>
<p>嘀咕了这么多，我大概还需要深入理解以下内容。</p>
<h1 id="3-需要探索的底层知识"><a href="#3-需要探索的底层知识" class="headerlink" title="3.需要探索的底层知识"></a>3.需要探索的底层知识</h1><h2 id="1-iOS"><a href="#1-iOS" class="headerlink" title="1.iOS"></a>1.iOS</h2><ul>
<li>面向对象</li>
<li>内存管理</li>
<li>Runtime</li>
<li>RunLoop</li>
<li>多线程 &amp;&amp; 锁</li>
<li>网络</li>
<li>UI &amp;&amp; 渲染流水线</li>
<li>性能优化</li>
<li>文件系统 - 沙盒</li>
<li>数据库</li>
<li>第三方框架</li>
<li>Swift</li>
<li>动态链接器</li>
<li>移动端技术架构</li>
<li>逆向</li>
</ul>
<h2 id="2-计算机基础"><a href="#2-计算机基础" class="headerlink" title="2.计算机基础"></a>2.计算机基础</h2><ul>
<li>数据结构</li>
<li>算法</li>
<li>操作系统</li>
<li>编译原理</li>
<li>网络编程</li>
</ul>
<h2 id="3-编程语言"><a href="#3-编程语言" class="headerlink" title="3.编程语言"></a>3.编程语言</h2><ul>
<li>OC &amp;&amp; Swift</li>
<li>C &amp;&amp; C++</li>
<li>JS &amp;&amp; TS</li>
<li>Python</li>
<li>Java</li>
<li>Dart</li>
<li>Kotlin</li>
</ul>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><ul>
<li>设计模式</li>
<li>软件工程</li>
<li>数据库</li>
<li>图形学</li>
<li>音视频</li>
<li>浏览器</li>
<li>跨平台</li>
</ul>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>序</tag>
      </tags>
  </entry>
</search>
