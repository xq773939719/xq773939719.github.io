<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="我的第一篇博客文章"><a href="#我的第一篇博客文章" class="headerlink" title="我的第一篇博客文章"></a>我的第一篇博客文章</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote>
<p>这是一个测试</p>
</blockquote>
<h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><blockquote>
<p>这是一个测试</p>
</blockquote>
<h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h2><blockquote>
<p>这是一个测试</p>
</blockquote>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2>]]></content>
  </entry>
  <entry>
    <title>[重学技术]iOS NSObject</title>
    <url>/posts/%E9%87%8D%E5%AD%A6%E6%8A%80%E6%9C%AF-iOS-NSObject/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote>
<p>[重学技术]系列主要是针对笔者自己的能力进行的针对性学习，不代表广大读者的情况。</p>
</blockquote>
<h2 id="带着问题出发"><a href="#带着问题出发" class="headerlink" title="带着问题出发"></a>带着问题出发</h2><ul>
<li>什么是 NSObject</li>
<li>NSObject 的本质</li>
</ul>
<h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h2 id="1-以代码开始"><a href="#1-以代码开始" class="headerlink" title="1.以代码开始"></a>1.以代码开始</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *p = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, <span class="keyword">sizeof</span>(p)); <span class="comment">// 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, <span class="keyword">sizeof</span>(&amp;p)); <span class="comment">// 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, <span class="keyword">sizeof</span>(p.class)); <span class="comment">// 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSObject</span>.class)); <span class="comment">// 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> objc_object)); <span class="comment">// 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, class_getInstanceSize(p.class)); <span class="comment">// 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%lu&quot;</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="type">void</span> *)(p))); <span class="comment">// 16</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里可以看出 p 指针指向一块内存区域，&amp;p 即是 NSObject 的一个实例对象的所在的地址。<br>在M2机器下，一个指针大小为8字节，所以sizeof(p) &#x3D; 8。<br>NSObject &#x3D; struct objc_object { struct objc_class *isa; } 占用一个指针 &#x3D; 8。<br>p.class &#x3D; NSObject &#x3D; 8<br>NSObject.class &#x3D; 元类 &#x3D; { struct objc_class *isa; } 占用一个指针 &#x3D; 8。<br>通过class_getInstanceSize的结果对比malloc_size，class_getInstanceSize表示实际可用的的内存空间大小，malloc_size表示为实例分配的内存的大小，由于该实例内部存储一个isa指针，已经占用了8字节，同时为了保证16位对其，分配了16位的整数倍内存空间。从而导致，填充了8字节的0。<br>SO!<br>class_getInstanceSize的结果就是除了isa指针占用之外的内存大小(16 - isa(8) &#x3D; 8)。<br>malloc_size的结果是实例占用的全部内存大小(16)。</p>
</blockquote>
<h2 id="2-一行指令"><a href="#2-一行指令" class="headerlink" title="2.一行指令"></a>2.一行指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc &#123;源文件&#125; [-o] [&#123;目标文件&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="3-三段代码"><a href="#3-三段代码" class="headerlink" title="3.三段代码"></a>3.三段代码</h2><h3 id="1-主函数"><a href="#1-主函数" class="headerlink" title="1.主函数"></a>1.主函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Foundation头文件展开的部分 超多行</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XXX XXX</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSObject *p = ((NSObject *(*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)(</span><br><span class="line">                (id)((NSObject *(*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)(</span><br><span class="line">                    (id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSObject&quot;</span>),</span><br><span class="line">                    <span class="built_in">sel_registerName</span>(<span class="string">&quot;alloc&quot;</span>)</span><br><span class="line">                ),</span><br><span class="line">                <span class="built_in">sel_registerName</span>(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">            );</span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;<span class="number">0</span>, <span class="built_in">sizeof</span>(p)); <span class="comment">// 指针类型 = 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;XXX1, <span class="built_in">sizeof</span>(&amp;p)); <span class="comment">// 指针类型 = 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;XXX2, <span class="built_in">sizeof</span>((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)p, <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>))); <span class="comment">// Class = struct objc_class * 指针类型 = 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;XXX3, <span class="built_in">sizeof</span>((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;NSObject&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>))); <span class="comment">// Class = struct objc_class * 指针类型 = 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;XXX4, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> objc_object)); <span class="comment">// struct objc_object 包含ias指针 = 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;XXX5, <span class="built_in">class_getInstanceSize</span>(((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)p, <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>)))); <span class="comment">// word_align(unalignedInstanceSize()) = 8</span></span><br><span class="line">        <span class="built_in">NSLog</span>((NSString *)&amp;XXX6, <span class="built_in">malloc_size</span>((__bridge <span class="type">const</span> <span class="type">void</span> *)(p))); <span class="comment">// isa + +ivar + 填充 = 16位对齐</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="2-需要关注的部分"><a href="#2-需要关注的部分" class="headerlink" title="2.需要关注的部分"></a>2.需要关注的部分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> NSObject; <span class="comment">// NSObject</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NSObject_IMPL</span> &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class; <span class="comment">// Class</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id; <span class="comment">// id</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_selector</span> *SEL; <span class="comment">// SEL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">// IMP</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> BOOL; <span class="comment">// BOOL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>NSObject_IMPL &#x3D;&#x3D; NSObject 一个实例对应的结构，所有实例对象的操作都是通过 isa 指针操作<br>类对象 + 元类对象 &#x3D; NSObject</p>
</blockquote>
<h3 id="3-关键方法"><a href="#3-关键方法" class="headerlink" title="3.关键方法"></a>3.关键方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">objc_msgSend</span>(id, SEL) </span><br><span class="line"><span class="built_in">objc_getClass</span>(<span class="type">const</span> <span class="type">char</span> *name) &#123;</span><br><span class="line">    <span class="comment">// ① OC类</span></span><br><span class="line">    result = getClassExceptSomeSwift + realizeClassMaybeSwiftAndUnlock</span><br><span class="line">    <span class="comment">// ② Swift类</span></span><br><span class="line">    look_up_class -&gt; <span class="keyword">for</span>(tls = _objc_fetch_pthread_data) -&gt; may be nil</span><br><span class="line">    result = swiftcls = GetClassHook</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sel_registerName</span>(<span class="type">const</span> <span class="type">char</span> *name)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拆分结构后比较清晰，它们分别完成一些任务</p>
</blockquote>
<pre><code>- objc_msgSend(id, SEL, ...) 负责消息发送，传入接收方、方法、参数。汇编实现
- objc_getClass(const char *name) 负责通过类名获取类对象
- sel_registerName(const char *name) 负责通过方法名拿到方法
</code></pre>
<h2 id="4-分析"><a href="#4-分析" class="headerlink" title="4.分析"></a>4.分析</h2><h3 id="1-NSObject"><a href="#1-NSObject" class="headerlink" title="1.NSObject"></a>1.NSObject</h3><p>从源码的<code>NSObject.h</code>,<code>NSObject.mm</code>,<code>objc-object.h</code>,<code>objc-private.h</code>,<code>objc-runtime-new.h</code>看，关键是<code>_objc_</code>, <code>object_</code>, <code>class_</code>开头的核心方法以及内部的结构体|类:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象本身</span></span><br><span class="line">+ (<span class="type">id</span>)<span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象本身</span></span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类对象</span></span><br><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，获取实例的，类对象</span></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，获取当前类的，父类对象</span></span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，获取当前实例的，父类对象</span></span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>]-&gt;getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是不是cls</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，判断当前实例，是不是cls的实例</span></span><br><span class="line">- (<span class="type">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是不是cls的子类对象</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，判断当前实例，是不是cls的子类对象的实例</span></span><br><span class="line">- (<span class="type">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是不是cls的子类对象</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isSubclassOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是不是obj的父类对象</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isAncestorOfObject:(<span class="built_in">NSObject</span> *)obj &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [obj <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == <span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法 (实例 方法 相应的类对象)</span></span><br><span class="line">+ (<span class="type">BOOL</span>)instancesRespondToSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> class_respondsToSelector_inst(<span class="literal">nil</span>, sel, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法 (实例 方法 相应的类对象)</span></span><br><span class="line">+ (<span class="type">BOOL</span>)respondsToSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> class_respondsToSelector_inst(<span class="keyword">self</span>, sel, <span class="keyword">self</span>-&gt;ISA());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法 (实例 方法 相应的类对象)</span></span><br><span class="line">- (<span class="type">BOOL</span>)respondsToSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> class_respondsToSelector_inst(<span class="keyword">self</span>, sel, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前类对象，是否遵循某个协议</span></span><br><span class="line">+ (<span class="type">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="keyword">if</span> (!protocol) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (class_conformsToProtocol(tcls, protocol)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，判断当前实例，是否遵循某个协议</span></span><br><span class="line">- (<span class="type">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="keyword">if</span> (!protocol) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (class_conformsToProtocol(tcls, protocol)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象哈希</span></span><br><span class="line">+ (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootHash(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例哈希</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootHash(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象是否相等(指针维度)</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isEqual:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">return</span> obj == (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例是否相等(指针维度)</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqual:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ??? override point</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isFault &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ??? override point</span></span><br><span class="line">- (<span class="type">BOOL</span>)isFault &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否代理 override point</span></span><br><span class="line">+ (<span class="type">BOOL</span>)isProxy &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否代理 override point</span></span><br><span class="line">- (<span class="type">BOOL</span>)isProxy &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，SEL -&gt; IMP 查询</span></span><br><span class="line">+ (IMP)instanceMethodForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> class_getMethodImplementation(<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于object_getMethodImplementation包装了class_getMethodImplementation</span></span><br><span class="line">IMP object_getMethodImplementation(<span class="type">id</span> obj, SEL name) &#123;</span><br><span class="line">    Class cls = (obj ? obj-&gt;getIsa() : <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">return</span> class_getMethodImplementation(cls, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法，SEL -&gt; IMP 查询</span></span><br><span class="line">+ (IMP)methodForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> object_getMethodImplementation((<span class="type">id</span>)<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法，SEL -&gt; IMP 查询</span></span><br><span class="line">- (IMP)methodForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> object_getMethodImplementation(<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第一环 当前对象处理</span></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第一环 当前对象处理</span></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析最终崩溃点</span></span><br><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">+ (<span class="type">void</span>)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[%s %s]: unrecognized selector sent to instance %p&quot;</span>,</span><br><span class="line">                class_getName(<span class="keyword">self</span>), sel_getName(sel), <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析最终崩溃点</span></span><br><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">- (<span class="type">void</span>)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;</span>,</span><br><span class="line">                object_getClassName(<span class="keyword">self</span>), sel_getName(sel), <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态调用类方法</span></span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel, obj);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj1 withObject:(<span class="type">id</span>)obj2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>, <span class="type">id</span>))objc_msgSend)((<span class="type">id</span>)<span class="keyword">self</span>, sel, obj1, obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态调用实例方法</span></span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL))objc_msgSend)(<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)sel withObject:(<span class="type">id</span>)obj1 withObject:(<span class="type">id</span>)obj2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">id</span>(*)(<span class="type">id</span>, SEL, <span class="type">id</span>, <span class="type">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj1, obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第三环 签名</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[NSObject instanceMethodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第三环 签名</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;-[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第三环 完整消息转发</span></span><br><span class="line">+ (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第三环 完整消息转发</span></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第二环 快速消息转发 转发给另一个对象</span></span><br><span class="line">+ (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析第二环 快速消息转发 转发给另一个对象</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象描述 override point</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSString)</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)debugDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> description];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象描述 override point</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSString)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)debugDescription &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> description];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.对象的出生</span></span><br><span class="line">+ (<span class="type">id</span>)new &#123;</span><br><span class="line">    <span class="keyword">return</span> [callAlloc(<span class="keyword">self</span>, <span class="literal">false</span><span class="comment">/*checkNil*/</span>) init];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">+ (<span class="type">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAllocWithZone(<span class="keyword">self</span>, (objc_zone_t)zone);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">+ (<span class="type">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.引用计数</span></span><br><span class="line">+ (<span class="type">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">BOOL</span>)_tryRetain &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ULONG_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootRetain(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="type">BOOL</span>)_tryRetain &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootTryRetain(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootRetainCount(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">+ (<span class="type">BOOL</span>)allowsWeakReference &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">BOOL</span>)retainWeakReference &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)allowsWeakReference &#123;</span><br><span class="line">    <span class="keyword">return</span> ! [<span class="keyword">self</span> _isDeallocating];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)retainWeakReference &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> _tryRetain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.存活空间</span></span><br><span class="line">+ (<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> _NSZone *)_objc_rootZone(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> _NSZone *)_objc_rootZone(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.续命</span></span><br><span class="line">+ (<span class="type">id</span>)<span class="keyword">copy</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)copyWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)<span class="keyword">copy</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">id</span>)<span class="keyword">self</span> copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)mutableCopy &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">id</span>)mutableCopyWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)mutableCopy &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">id</span>)<span class="keyword">self</span> mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.对象的消亡</span></span><br><span class="line">+ (<span class="type">id</span>)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">id</span>)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="type">id</span>)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAutorelease(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">oneway</span> <span class="type">void</span>)release &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (<span class="keyword">oneway</span> <span class="type">void</span>)release &#123;</span><br><span class="line">    _objc_rootRelease(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">+ (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Replaced by NSZombies</span></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">BOOL</span>)_isDeallocating &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)_isDeallocating &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootIsDeallocating(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Previously used by GC. Now a placeholder for binary compatibility.</span></span><br><span class="line">- (<span class="type">void</span>) finalize &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-objc-object"><a href="#2-objc-object" class="headerlink" title="2.objc_object"></a>2.objc_object</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-private.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> isa_storage[<span class="built_in">sizeof</span>(<span class="type">isa_t</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">isa_t</span> &amp;<span class="title">isa</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">isa_t</span> *&gt;(isa_storage); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">isa_t</span> &amp;<span class="title">isa</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">isa_t</span> *&gt;(isa_storage); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">(<span class="type">bool</span> authenticated = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA</span></span><br><span class="line">    <span class="function">Class <span class="title">rawISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">isaBits</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initIsa() should be used to init the isa of new objects only.</span></span><br><span class="line">    <span class="comment">// If this object already has an isa, use changeIsa() for correctness.</span></span><br><span class="line">    <span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></span><br><span class="line">    <span class="comment">// initClassIsa(): class objects</span></span><br><span class="line">    <span class="comment">// initProtocolIsa(): protocol objects</span></span><br><span class="line">    <span class="comment">// initIsa(): other objects</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=false*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initClassIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=maybe*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initProtocolIsa</span><span class="params">(Class cls <span class="comment">/*nonpointer=maybe*/</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initInstanceIsa</span><span class="params">(Class cls, <span class="type">bool</span> hasCxxDtor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// changeIsa() should be used to change the isa of existing objects.</span></span><br><span class="line">    <span class="comment">// If this is a new object, use initIsa() for performance.</span></span><br><span class="line">    <span class="function">Class <span class="title">changeIsa</span><span class="params">(Class newCls)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNonpointerIsa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaggedPointer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBasicTaggedPointer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isExtTaggedPointer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object may have associated objects?</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAssociatedObjects</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHasAssociatedObjects</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object may be weakly referenced?</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWeaklyReferenced</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWeaklyReferenced_nolock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object may be uniquely referenced?</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUniquelyReferenced</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object may have -.cxx_destruct implementation?</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCxxDtor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimized calls to retain/release methods</span></span><br><span class="line">    <span class="function">id <span class="title">retain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">autorelease</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implementations of retain/release methods</span></span><br><span class="line">    <span class="function">id <span class="title">rootRetain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rootRelease</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">rootAutorelease</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rootTryRetain</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rootReleaseShouldDealloc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">rootRetainCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implementation of dealloc methods</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">rootIsDeallocating</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearDeallocating</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rootDealloc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initIsa</span><span class="params">(Class newCls, <span class="type">bool</span> nonpointer, <span class="type">bool</span> hasCxxDtor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slow paths for inline control</span></span><br><span class="line">    <span class="function">id <span class="title">rootAutorelease2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="comment">// Controls what parts of root&#123;Retain,Release&#125; to emit/inline</span></span><br><span class="line">    <span class="comment">// - Full means the full (slow) implementation</span></span><br><span class="line">    <span class="comment">// - Fast means the fastpaths only</span></span><br><span class="line">    <span class="comment">// - FastOrMsgSend means the fastpaths but checking whether we should call</span></span><br><span class="line">    <span class="comment">//   -retain/-release or Swift, for the usage of objc_&#123;retain,release&#125;</span></span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">RRVariant</span> &#123;</span><br><span class="line">        Full,</span><br><span class="line">        Fast,</span><br><span class="line">        FastOrMsgSend,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unified retain count manipulation for nonpointer isa</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> id <span class="title">rootRetain</span><span class="params">(<span class="type">bool</span> tryRetain, RRVariant variant)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">rootRelease</span><span class="params">(<span class="type">bool</span> performDealloc, RRVariant variant)</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">rootRetain_overflow</span><span class="params">(<span class="type">bool</span> tryRetain)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">rootRelease_underflow</span><span class="params">(<span class="type">bool</span> performDealloc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearDeallocating_slow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Side table retain count overflow for nonpointer isa</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SidetableBorrow</span> &#123; <span class="type">size_t</span> borrowed, remaining; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_moveExtraRC_nolock</span><span class="params">(<span class="type">size_t</span> extra_rc, <span class="type">bool</span> isDeallocating, <span class="type">bool</span> weaklyReferenced)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_addExtraRC_nolock</span><span class="params">(<span class="type">size_t</span> delta_rc)</span></span>;</span><br><span class="line">    <span class="function">SidetableBorrow <span class="title">sidetable_subExtraRC_nolock</span><span class="params">(<span class="type">size_t</span> delta_rc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">sidetable_getExtraRC_nolock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_clearExtraRC_nolock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Side-table-only retain count</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_isDeallocating</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_clearDeallocating</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_isWeaklyReferenced</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sidetable_setWeaklyReferenced_nolock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">id <span class="title">sidetable_retain</span><span class="params">(<span class="type">bool</span> locked = <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">id <span class="title">sidetable_retain_slow</span><span class="params">(SideTable&amp; table)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">sidetable_release</span><span class="params">(<span class="type">bool</span> locked = <span class="literal">false</span>, <span class="type">bool</span> performDealloc = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">sidetable_release_slow</span><span class="params">(SideTable&amp; table, <span class="type">bool</span> performDealloc = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_tryRetain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uintptr_t</span> <span class="title">sidetable_retainCount</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sidetable_present</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performDealloc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-objc-class-objc-object"><a href="#3-objc-class-objc-object" class="headerlink" title="3.objc_class: objc_object"></a>3.objc_class: objc_object</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="built_in">objc_class</span>(<span class="type">const</span> objc_class&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">objc_class</span>(objc_class&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> objc_class&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(objc_class&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Class <span class="title">getSuperclass</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">if</span> ISA_SIGNING_AUTH_MODE == ISA_SIGNING_AUTH</span></span><br><span class="line">        <span class="keyword">if</span> (superclass == Nil)</span><br><span class="line">            <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPERCLASS_SIGNING_TREAT_UNSIGNED_AS_NIL</span></span><br><span class="line">        <span class="type">void</span> *stripped = <span class="built_in">ptrauth_strip</span>((<span class="type">void</span> *)superclass, ISA_SIGNING_KEY);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">void</span> *)superclass == stripped) &#123;</span><br><span class="line">            <span class="type">void</span> *resigned = <span class="built_in">ptrauth_sign_unauthenticated</span>(stripped, ISA_SIGNING_KEY, <span class="built_in">ptrauth_blend_discriminator</span>(&amp;superclass, ISA_SIGNING_DISCRIMINATOR_CLASS_SUPERCLASS));</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">void</span> *)superclass != resigned)</span><br><span class="line">                <span class="keyword">return</span> Nil;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *result = <span class="built_in">ptrauth_auth_data</span>((<span class="type">void</span> *)superclass, ISA_SIGNING_KEY, <span class="built_in">ptrauth_blend_discriminator</span>(&amp;superclass, ISA_SIGNING_DISCRIMINATOR_CLASS_SUPERCLASS));</span><br><span class="line">        <span class="keyword">return</span> (Class)result;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> (Class)<span class="built_in">ptrauth_strip</span>((<span class="type">void</span> *)superclass, ISA_SIGNING_KEY);</span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> superclass;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuperclass</span><span class="params">(Class newSuperclass)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ISA_SIGNING_SIGN_MODE == ISA_SIGNING_SIGN_ALL</span></span><br><span class="line">        superclass = (Class)<span class="built_in">ptrauth_sign_unauthenticated</span>((<span class="type">void</span> *)newSuperclass, ISA_SIGNING_KEY, <span class="built_in">ptrauth_blend_discriminator</span>(&amp;superclass, ISA_SIGNING_DISCRIMINATOR_CLASS_SUPERCLASS));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        superclass = newSuperclass;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setData</span>(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">class_ro_t</span> *<span class="title">safe_ro</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInfo</span><span class="params">(<span class="type">uint32_t</span> set)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">data</span>()-&gt;<span class="built_in">setFlags</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearInfo</span><span class="params">(<span class="type">uint32_t</span> clear)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">data</span>()-&gt;<span class="built_in">clearFlags</span>(clear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set and clear must not overlap</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeInfo</span><span class="params">(<span class="type">uint32_t</span> set, <span class="type">uint32_t</span> clear)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">ASSERT</span>((set &amp; clear) == <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">data</span>()-&gt;<span class="built_in">changeFlags</span>(set, clear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAllocNonpointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(!<span class="built_in">isFuture</span>());</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">instancesRequireRawIsa</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSwiftStable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">isSwiftStable</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSwiftLegacy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">isSwiftLegacy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnySwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">isAnySwift</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSwiftStable_ButAllowLegacyForNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">isSwiftStable_ButAllowLegacyForNow</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">swiftClassFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint32_t</span> *)(&amp;bits + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">usesSwiftRefcounting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isSwiftStable</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">swiftClassFlags</span>() &amp; <span class="number">2</span>); <span class="comment">//ClassFlags::UsesSwiftRefcounting</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCallSwiftRR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// !hasCustomCore() is being used as a proxy for isInitialized(). All</span></span><br><span class="line">        <span class="comment">// classes with Swift refcounting are !hasCustomCore() (unless there are</span></span><br><span class="line">        <span class="comment">// category or swizzling shenanigans), but that bit is not set until a</span></span><br><span class="line">        <span class="comment">// class is initialized. Checking isInitialized requires an extra</span></span><br><span class="line">        <span class="comment">// indirection that we want to avoid on RR fast paths.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// In the unlikely event that someone causes a class with Swift</span></span><br><span class="line">        <span class="comment">// refcounting to be hasCustomCore(), we&#x27;ll fall back to sending -retain</span></span><br><span class="line">        <span class="comment">// or -release, which is still correct.</span></span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">hasCustomCore</span>() &amp;&amp; <span class="built_in">usesSwiftRefcounting</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStubClass</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">uintptr_t</span> isa = (<span class="type">uintptr_t</span>)<span class="built_in">isaBits</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;= isa &amp;&amp; isa &lt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swift stable ABI built for old deployment targets looks weird.</span></span><br><span class="line">    <span class="comment">// The is-legacy bit is set for compatibility with old libobjc.</span></span><br><span class="line">    <span class="comment">// We are on a &quot;new&quot; deployment target so we need to rewrite that bit.</span></span><br><span class="line">    <span class="comment">// These stable-with-legacy-bit classes are distinguished from real</span></span><br><span class="line">    <span class="comment">// legacy classes using another bit in the Swift data</span></span><br><span class="line">    <span class="comment">// (ClassFlags::IsSwiftPreStableABI)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnfixedBackwardDeployingStableSwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Only classes marked as Swift legacy need apply.</span></span><br><span class="line">        <span class="keyword">if</span> (!bits.<span class="built_in">isSwiftLegacy</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the true legacy vs stable distinguisher.</span></span><br><span class="line">        <span class="comment">// The low bit of Swift&#x27;s ClassFlags is SET for true legacy</span></span><br><span class="line">        <span class="comment">// and UNSET for stable pretending to be legacy.</span></span><br><span class="line">        <span class="type">bool</span> isActuallySwiftLegacy = <span class="built_in">bool</span>(<span class="built_in">swiftClassFlags</span>() &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> !isActuallySwiftLegacy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fixupBackwardDeployingStableSwift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isUnfixedBackwardDeployingStableSwift</span>()) &#123;</span><br><span class="line">            <span class="comment">// Class really is stable Swift, pretending to be pre-stable.</span></span><br><span class="line">            <span class="comment">// Fix its lie.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// N.B. At this point, bits is *always* a class_ro pointer; we</span></span><br><span class="line">            <span class="comment">// can&#x27;t use setIsSwiftStable() because that only works for a</span></span><br><span class="line">            <span class="comment">// class_rw pointer.</span></span><br><span class="line">            bits.<span class="built_in">setIsSwiftStableRO</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_objc_swiftMetadataInitializer <span class="title">swiftMetadataInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">swiftMetadataInitializer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return YES if the class&#x27;s ivars are managed by ARC,</span></span><br><span class="line">    <span class="comment">// or the class is MRC but has ARC-style weak ivars.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAutomaticIvars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;flags &amp; (RO_IS_ARC | RO_HAS_WEAK_WITHOUT_ARC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return YES if the class&#x27;s ivars are managed by ARC.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isARC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;flags &amp; RO_IS_ARC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">forbidsAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">data</span>()-&gt;flags &amp; RW_FORBIDS_ASSOCIATED_OBJECTS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="comment">// Tracked in non-pointer isas; not tracked otherwise</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">instancesHaveAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this may be an unrealized future class in the CF-bridged case</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInstancesHaveAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this may be an unrealized future class in the CF-bridged case</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isFuture</span>()  ||  <span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">setInfo</span>(RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">shouldGrowCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setShouldGrowCache</span><span class="params">(<span class="type">bool</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fixme good or bad for memory use?</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;bits.<span class="built_in">flags</span>() &amp; RW_INITIALIZING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">        <span class="built_in">ISA</span>()-&gt;<span class="built_in">setInfo</span>(RW_INITIALIZING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;bits.<span class="built_in">flags</span>() &amp; RW_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInitialized</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLoadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// any class registered for +load is definitely loadable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IMP <span class="title">getLoadMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Locking: To prevent concurrent realization, hold runtimeLock.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRealized</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">isStubClass</span>() &amp;&amp; (bits.<span class="built_in">flags</span>() &amp; RW_REALIZED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true if this is an unrealized future class.</span></span><br><span class="line">    <span class="comment">// Locking: To prevent concurrent realization, hold runtimeLock.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFuture</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isStubClass</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">flags</span>() &amp; RW_FUTURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ASSERT_THIS_NOT_NULL;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FAST_CACHE_META</span></span><br><span class="line">        <span class="keyword">return</span> cache.<span class="built_in">getBit</span>(FAST_CACHE_META);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_META;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Like isMetaClass, but also valid on un-realized classes</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMetaClassMaybeUnrealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(<span class="built_in">offsetof</span>(<span class="type">class_rw_t</span>, flags) == <span class="built_in">offsetof</span>(<span class="type">class_ro_t</span>, flags), <span class="string">&quot;flags alias&quot;</span>);</span><br><span class="line">        <span class="built_in">static_assert</span>(RO_META == RW_META, <span class="string">&quot;flags alias&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isStubClass</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">flags</span>() &amp; RW_META;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NOT identical to this-&gt;ISA when this is a metaclass</span></span><br><span class="line">    <span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isMetaClassMaybeUnrealized</span>()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRootClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSuperclass</span>() == nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRootMetaclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ISA</span>() == (Class)<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this class does not have a name already, we can ask Swift to construct one for us.</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">installMangledNameForLazilyNamedClass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the class&#x27;s mangled name, or NULL if the class has a lazy</span></span><br><span class="line">    <span class="comment">// name that hasn&#x27;t been created yet.</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">nonlazyMangledName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>()-&gt;<span class="built_in">getName</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">mangledName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fixme can&#x27;t assert locks here</span></span><br><span class="line">        ASSERT_THIS_NOT_NULL;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *result = <span class="built_in">nonlazyMangledName</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="comment">// This class lazily instantiates its name. Emplace and</span></span><br><span class="line">            <span class="comment">// return it.</span></span><br><span class="line">            result = <span class="built_in">installMangledNameForLazilyNamedClass</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the class&#x27;s mangled name, or NULL if it has a lazy name that hasn&#x27;t</span></span><br><span class="line">    <span class="comment">// been created yet, WITHOUT authenticating the signed class_ro pointer.</span></span><br><span class="line">    <span class="comment">// This exists sosely for objc_debug_class_getNameRaw to use.</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">rawUnsafeMangledName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Strip the class_ro pointer instead of authenticating so that we can</span></span><br><span class="line">        <span class="comment">// handle classes without signed class_ro pointers in the shared cache</span></span><br><span class="line">        <span class="comment">// even if they haven&#x27;t been officially loaded yet. rdar://90415774</span></span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>&lt;Authentication::Strip&gt;()-&gt;<span class="built_in">getName</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">demangledName</span><span class="params">(<span class="type">bool</span> needsLock)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">nameForLogging</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// May be unaligned depending on class&#x27;s ivars.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">unalignedInstanceStart</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;instanceStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class&#x27;s instance start rounded up to a pointer-size boundary.</span></span><br><span class="line">    <span class="comment">// This is used for ARC layout bitmaps.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">alignedInstanceStart</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceStart</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// May be unaligned depending on class&#x27;s ivars.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">unalignedInstanceSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;instanceSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceSize</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="type">size_t</span> extraBytes)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fastpath</span>(cache.<span class="built_in">hasFastInstanceSize</span>(extraBytes))) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.<span class="built_in">fastInstanceSize</span>(extraBytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> size = <span class="built_in">alignedInstanceSize</span>() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInstanceSize</span><span class="params">(<span class="type">uint32_t</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">data</span>()-&gt;flags &amp; RW_REALIZING);</span><br><span class="line">        <span class="keyword">auto</span> ro = <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>();</span><br><span class="line">        <span class="keyword">if</span> (newSize != ro-&gt;instanceSize) &#123;</span><br><span class="line">            <span class="built_in">ASSERT</span>(<span class="built_in">data</span>()-&gt;flags &amp; RW_COPIED_RO);</span><br><span class="line">            *<span class="built_in">const_cast</span>&lt;<span class="type">uint32_t</span> *&gt;(&amp;ro-&gt;instanceSize) = newSize;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">setFastInstanceSize</span>(newSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chooseClassArrayIndex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setClassArrayIndex</span><span class="params">(<span class="type">unsigned</span> Idx)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setClassArrayIndex</span>(Idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">classArrayIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">classArrayIndex</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-其他结构"><a href="#4-其他结构" class="headerlink" title="4.其他结构"></a>4.其他结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">preopt_cache_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RelativePointer</span>: <span class="type">nocopy_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stub_class_t</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">method_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ivar_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">property_t</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">entsize_list_tt</span> &#123;&#125; <span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">method_list_t</span>: entsize_list_tt &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">protocol_t</span> : objc_object &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">protocol_list_t</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_t</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_data_bits_t</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list_array_tt</span> &#123;&#125; <span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">method_array_t</span>: list_array_tt &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">property_array_t</span>: list_array_tt &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">protocol_array_t</span>: list_array_tt &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">swift_class_t</span>: objc_class &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">category_t</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-一切皆对象"><a href="#5-一切皆对象" class="headerlink" title="5.一切皆对象"></a>5.<code>一切皆对象</code></h3><p>从源码可以看到 objc_class 继承自 objc_object，从而具有了对象的能力。<br>可以看到 NSObject_IMPL 中 isa 作为 Class 类型，本质上指向了自己对应的 objc_class 类型的类对象。<br>同时 objc_class 中 isa 作为 Class 类型，指向了类对象所对应的元类对象。</p>
<blockquote>
<p>instance.isa -n-&gt; 类对象.isa -1-&gt; 元类对象.isa -&gt; 根元类对象。<br>从设计者角度来看，类对象会占用空间，但是不需要存储多份，<code>把变化的部分(状态：实例变量)外置，运行时存储到堆栈；而不变的部分(行为：实例方法)内置，保存在一个全局访问的位置</code>，所以可以认为类对象为实例提供了<code>原型</code>，通过 isa 连接。<br>元类对象同样会占用空间，同样不需要存储多份，<code>把变化的部分(状态：类变量)外置，运行时存储到全局区域；而不变的部分(行为：类方法)内置，保存在一个全局访问的位置</code>，同样认为元类对象为类对象提供了<code>原型</code>，通过 isa 连接。</p>
</blockquote>
<h3 id="6-代码中出现的方法"><a href="#6-代码中出现的方法" class="headerlink" title="6.代码中出现的方法"></a>6.代码中出现的方法</h3><p>1.[oc 语言层面]<br>_objc_rootHash<br>_objc_fatal</p>
<p>_objc_rootAlloc<br>_objc_rootInit { return obj; &#x2F;&#x2F; do nothing }<br>_objc_rootRetain<br>_objc_rootTryRetain { return rootRetain(tryRetain, RRVariant::Fast) }<br>_objc_rootRetainCount<br>_objc_rootZone</p>
<p>_objc_rootAutorelease<br>_objc_rootRelease<br>_objc_rootDealloc<br>_objc_rootIsDeallocating</p>
<p>2.[class 类层面]<br>class_respondsToSelector_inst<br>class_conformsToProtocol<br>class_getMethodImplementation<br>class_getName</p>
<p>3.[object 实例层面]<br>object_getClass<br>object_getMethodImplementation<br>object_getClassName</p>
<p>4.[SEL 方法层面]<br>sel_getName<br>sel_registerName</p>
<h3 id="7-各个击破"><a href="#7-各个击破" class="headerlink" title="7.各个击破"></a>7.各个击破</h3><h4 id="1-objc-rootHash"><a href="#1-objc-rootHash" class="headerlink" title="1._objc_rootHash"></a>1._objc_rootHash</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject.mm</span></span><br><span class="line"><span class="comment">// 本质是对象指针的整形值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="type">uintptr_t</span> _objc_rootHash(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uintptr_t</span>)obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-objc-fatal-致命错误-logs-print-—-abort-terminate-trap"><a href="#2-objc-fatal-致命错误-logs-print-—-abort-terminate-trap" class="headerlink" title="2._objc_fatal 致命错误 logs -&gt; print —&gt; abort -&gt; terminate + trap"></a>2._objc_fatal 致命错误 logs -&gt; print —&gt; abort -&gt; terminate + trap</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-os.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> _objc_fatal(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">    __attribute__((noreturn, cold, format (printf, <span class="number">1</span>, <span class="number">2</span>)));</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> _objc_fatal_with_reason(<span class="type">uint64_t</span> reason, <span class="type">uint64_t</span> flags,</span><br><span class="line">                                    <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">    __attribute__((noreturn, cold, format (printf, <span class="number">3</span>, <span class="number">4</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-errors.mm</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this routine handles severe runtime errors...like not being able</span></span><br><span class="line"><span class="comment"> * to read the mach headers, allocate space, etc...very uncommon.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> _objc_fatal(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap,fmt);</span><br><span class="line">    _objc_fatalv(OBJC_EXIT_REASON_UNSPECIFIED,</span><br><span class="line">                 OS_REASON_FLAG_ONE_TIME_FAILURE,</span><br><span class="line">                 fmt, ap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _objc_fatalv(<span class="type">uint64_t</span> reason, <span class="type">uint64_t</span> flags, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf1;</span><br><span class="line">    _objc_vasprintf(&amp;buf1, fmt, ap);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf2;</span><br><span class="line">    _objc_asprintf(&amp;buf2, <span class="string">&quot;objc[%d]: %s\n&quot;</span>, <span class="built_in">getpid</span>(), buf1);</span><br><span class="line">    _objc_syslog(buf2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DebugDontCrash) &#123;</span><br><span class="line">        <span class="type">char</span> *buf3;</span><br><span class="line">        _objc_asprintf(&amp;buf3, <span class="string">&quot;objc[%d]: HALTED\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        _objc_syslog(buf3);</span><br><span class="line">        _Exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        _objc_crashlog(buf1);</span><br><span class="line">        <span class="built_in">abort_with_reason</span>(OS_REASON_OBJC, reason, buf1, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xnu/libsyscall</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">abort_with_reason</span><span class="params">(<span class="type">uint32_t</span> reason_namespace, <span class="type">uint64_t</span> reason_code, <span class="type">const</span> <span class="type">char</span> *reason_string,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="type">uint64_t</span> reason_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">abort_with_payload_wrapper_internal</span>(reason_namespace, reason_code, <span class="number">0</span>, <span class="number">0</span>, reason_string, reason_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">abort_with_payload_wrapper_internal</span><span class="params">(<span class="type">uint32_t</span> reason_namespace, <span class="type">uint64_t</span> reason_code,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">void</span> *payload, <span class="type">uint32_t</span> payload_size, <span class="type">const</span> <span class="type">char</span> *reason_string,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">uint64_t</span> reason_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">sigset_t</span> unmask_signal;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Try to unmask SIGABRT before trapping to the kernel */</span></span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;unmask_signal);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;unmask_signal, SIGABRT);</span><br><span class="line">	<span class="built_in">sigprocmask</span>(SIG_UNBLOCK, &amp;unmask_signal, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	__abort_with_payload(reason_namespace, reason_code, payload, payload_size,</span><br><span class="line">			reason_string, reason_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If sending a SIGABRT failed, we try to fall back to SIGKILL */</span></span><br><span class="line">	<span class="built_in">terminate_with_payload</span>(<span class="built_in">getpid</span>(), reason_namespace, reason_code, payload, payload_size,</span><br><span class="line">			reason_string, reason_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Last resort, let&#x27;s use SIGTRAP (SIGILL on i386) */</span></span><br><span class="line">	<span class="built_in">sigemptyset</span>(&amp;unmask_signal);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;unmask_signal, SIGTRAP);</span><br><span class="line">	<span class="built_in">sigaddset</span>(&amp;unmask_signal, SIGILL);</span><br><span class="line">	<span class="built_in">sigprocmask</span>(SIG_UNBLOCK, &amp;unmask_signal, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	__builtin_trap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-objc-rootAlloc"><a href="#3-objc-rootAlloc" class="headerlink" title="3._objc_rootAlloc"></a>3._objc_rootAlloc</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject.mm</span></span><br><span class="line">id _objc_rootAlloc(Class cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callAlloc</span>(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初步分流</span></span><br><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE id</span></span><br><span class="line"><span class="function"><span class="title">callAlloc</span><span class="params">(Class cls, <span class="type">bool</span> checkNil, <span class="type">bool</span> allocWithZone=<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> nil; <span class="comment">// ① 校验</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomAWZ</span>())) &#123; <span class="comment">// ② 判断是否有自定义的 allocWithZone</span></span><br><span class="line">        <span class="keyword">return</span> _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="built_in">id</span>(*)(id, SEL, <span class="keyword">struct</span> _NSZone *))objc_msgSend)(cls, @<span class="built_in">selector</span>(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(cls, @<span class="built_in">selector</span>(alloc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// allocWithZone -&gt; _objc_rootAllocWithZone</span></span><br><span class="line">NEVER_INLINE</span><br><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, <span class="type">objc_zone_t</span>) &#123;</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter objc2忽略zone参数</span></span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, <span class="number">0</span>, nil, OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心方法 _class_createInstance</span></span><br><span class="line"><span class="type">static</span> ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="type">size_t</span> extraBytes, <span class="type">void</span> *zone,</span><br><span class="line">                              <span class="type">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="type">bool</span> cxxConstruct = <span class="literal">true</span>,</span><br><span class="line">                              <span class="type">size_t</span> *outAllocatedSize = nil) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">isRealized</span>()); <span class="comment">// ① 校验 类对象是否已经实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 判断 不太懂？ 不影响主流程</span></span><br><span class="line">    <span class="comment">// Read class&#x27;s info bits all at once for performance</span></span><br><span class="line">    <span class="type">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;<span class="built_in">hasCxxCtor</span>();</span><br><span class="line">    <span class="type">bool</span> hasCxxDtor = cls-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">    <span class="type">bool</span> fast = cls-&gt;<span class="built_in">canAllocNonpointer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    size = cls-&gt;<span class="built_in">instanceSize</span>(extraBytes); <span class="comment">// ③ 计算实例对象的size</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="type">size_t</span> extraBytes)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fastpath</span>(cache.<span class="built_in">hasFastInstanceSize</span>(extraBytes))) &#123; <span class="comment">// 缓存</span></span><br><span class="line">            <span class="keyword">return</span> cache.<span class="built_in">fastInstanceSize</span>(extraBytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> size = <span class="built_in">alignedInstanceSize</span>() + extraBytes; <span class="comment">// 计算</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="type">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceSize</span>()); &#123;</span><br><span class="line">                    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">word_align</span><span class="params">(<span class="type">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="type">uint32_t</span> <span class="title">unalignedInstanceSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">                        <span class="built_in">ASSERT</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>()-&gt;instanceSize; <span class="comment">// 这个值是怎么来的? 临时记录下</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// dyld加载流程</span></span><br><span class="line">                            objc_allocateClassPair &#123;</span><br><span class="line">                                ...</span><br><span class="line">                                cls  = <span class="built_in">alloc_class_for_subclass</span>(superclass, extraBytes);</span><br><span class="line">                                meta = <span class="built_in">alloc_class_for_subclass</span>(superclass, extraBytes);</span><br><span class="line">                                objc_initializeClassPair_internal &#123;</span><br><span class="line">                                    ...</span><br><span class="line">                                    cls-&gt;<span class="built_in">setInstanceSize</span>(cls_ro_w-&gt;instanceStart);</span><br><span class="line">                                    meta-&gt;<span class="built_in">setInstanceSize</span>(meta_ro_w-&gt;instanceStart);</span><br><span class="line">                                &#125;</span><br><span class="line">                                ...</span><br><span class="line">                            &#125;</span><br><span class="line">                            ...</span><br><span class="line">                            class_addIvar</span><br><span class="line">                            ...</span><br><span class="line">                            objc_registerClassPair</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>; <span class="comment">// 不满16字节 补满</span></span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 根据size 分配内存</span></span><br><span class="line">    id obj;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_ZONES</span></span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        obj = (id)<span class="built_in">malloc_zone_calloc</span>((<span class="type">malloc_zone_t</span> *)zone, <span class="number">1</span>, size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_ZONES</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④ 初始化isa</span></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, hasCxxDtor);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">initIsa</span>(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;<span class="built_in">initIsa</span>(cls);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">initIsa</span>(cls, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!hasCxxCtor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑤ 递归调用C++构造对象</span></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_cxxConstructFromClass</span>(obj, cls, construct_flags); &#123;</span><br><span class="line">        继承链向上尾递归 &#123;</span><br><span class="line">            ctor = (<span class="built_in">id</span>(*)(id))<span class="built_in">lookupMethodInClassAndLoadCache</span>(cls, SEL_cxx_construct);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fastpath</span>((*ctor)(obj))) <span class="keyword">return</span> obj;  <span class="comment">// ctor called and succeeded - ok</span></span><br><span class="line">            <span class="comment">// This class&#x27;s ctor was called and failed.</span></span><br><span class="line">            <span class="comment">// Call superclasses&#x27;s dtors to clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (supercls) <span class="built_in">object_cxxDestructFromClass</span>(obj, supercls);</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; OBJECT_CONSTRUCT_FREE_ONFAILURE) <span class="built_in">free</span>(obj);</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">                <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑥ 结束 返回对象obj地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-objc-rootRetain"><a href="#4-objc-rootRetain" class="headerlink" title="4._objc_rootRetain"></a>4._objc_rootRetain</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject.mm</span></span><br><span class="line">NEVER_INLINE id</span><br><span class="line">_objc_rootRetain(id obj) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">rootRetain</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// objc-object.h</span></span><br><span class="line"><span class="function">ALWAYS_INLINE id</span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRetain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rootRetain</span>(<span class="literal">false</span>, RRVariant::Fast); <span class="comment">// 核心引用计数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">uintptr_t</span> carry;</span><br><span class="line">            newisa.bits = <span class="built_in">addc</span>(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!newisa.nonpointer)) &#123;</span><br><span class="line">                <span class="built_in">ClearExclusive</span>(&amp;<span class="built_in">isa</span>().bits);</span><br><span class="line">                <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> <span class="built_in">sidetable_tryRetain</span>() ? (id)<span class="keyword">this</span> : nil;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">sidetable_retain</span>(sideTableLocked);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>(carry)) &#123;</span><br><span class="line">                <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">                <span class="keyword">if</span> (variant != RRVariant::Full) &#123;</span><br><span class="line">                    <span class="built_in">ClearExclusive</span>(&amp;<span class="built_in">isa</span>().bits);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">rootRetain_overflow</span>(tryRetain);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Leave half of the retain counts inline and</span></span><br><span class="line">                <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">                <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) <span class="built_in">sidetable_lock</span>();</span><br><span class="line">                sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">                transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">                newisa.extra_rc = RC_HALF;</span><br><span class="line">                newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-objc-rootRetainCount"><a href="#5-objc-rootRetainCount" class="headerlink" title="5._objc_rootRetainCount"></a>5._objc_rootRetainCount</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject.mm</span></span><br><span class="line"><span class="type">uintptr_t</span></span><br><span class="line">_objc_rootRetainCount(id obj) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">rootRetainCount</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-object.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRetainCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> (<span class="type">uintptr_t</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sidetable_lock</span>();</span><br><span class="line">    <span class="type">isa_t</span> bits = __c11_atomic_load((_Atomic <span class="type">uintptr_t</span> *)&amp;<span class="built_in">isa</span>().bits, __ATOMIC_RELAXED);</span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> rc = bits.extra_rc;</span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += <span class="built_in">sidetable_getExtraRC_nolock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sidetable_retainCount</span>() &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> objc_object::<span class="built_in">sidetable_retainCount</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> refcnt_result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            table.<span class="built_in">lock</span>();</span><br><span class="line">            RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (it != table.refcnts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">                refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">            &#125;</span><br><span class="line">            table.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> refcnt_result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-objc-rootAutorelease"><a href="#6-objc-rootAutorelease" class="headerlink" title="6._objc_rootAutorelease"></a>6._objc_rootAutorelease</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSOBject.mm</span></span><br><span class="line">NEVER_INLINE id</span><br><span class="line">_objc_rootAutorelease(id obj) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">rootAutorelease</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// objc-object.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> id</span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootAutorelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    <span class="type">bool</span> nonpointerIsa = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ISA_HAS_INLINE_RC</span></span><br><span class="line">    nonpointerIsa = <span class="built_in">isa</span>().nonpointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When we can cheaply determine if the object is deallocating, avoid</span></span><br><span class="line">    <span class="comment">// putting it in the pool. Refcounting doesn&#x27;t work on a deallocating object</span></span><br><span class="line">    <span class="comment">// so it&#x27;s pointless to put it in the pool, and potentially dangerous.</span></span><br><span class="line">    <span class="keyword">if</span> (nonpointerIsa &amp;&amp; <span class="built_in">isa</span>().<span class="built_in">isDeallocating</span>()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the class has custom dealloc initiation, we also want to avoid putting</span></span><br><span class="line">    <span class="comment">// deallocating instances in the pool even if it&#x27;s expensive to check. (UIView</span></span><br><span class="line">    <span class="comment">// and UIViewController need this. rdar://97186669)</span></span><br><span class="line">    <span class="keyword">if</span> (!nonpointerIsa &amp;&amp; <span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomDeallocInitiation</span>() &amp;&amp; <span class="built_in">rootIsDeallocating</span>())</span><br><span class="line">        <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prepareOptimizedReturn</span>((id)<span class="keyword">this</span>, <span class="literal">true</span>, ReturnAtPlus1)) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">isClass</span>())) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rootAutorelease2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSOBject.mm</span></span><br><span class="line">__attribute__((noinline,used))</span><br><span class="line"><span class="function">id</span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootAutorelease2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(!<span class="built_in">isTaggedPointer</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">autorelease</span>((id)<span class="keyword">this</span>); <span class="comment">// autorelease 后面详细分析</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">        AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">            <span class="keyword">if</span> (page &amp;&amp; !page-&gt;<span class="built_in">full</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-objc-rootRelease"><a href="#7-objc-rootRelease" class="headerlink" title="7._objc_rootRelease"></a>7._objc_rootRelease</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject.mm</span></span><br><span class="line">NEVER_INLINE <span class="type">void</span></span><br><span class="line">_objc_rootRelease(id obj) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj)</span><br><span class="line">    obj-&gt;<span class="built_in">rootRelease</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-object.h</span></span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="type">bool</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rootRelease</span>(<span class="literal">true</span>, RRVariant::Fast); <span class="comment">// 后面详细分析</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-objc-rootDealloc-objc-rootIsDeallocating"><a href="#8-objc-rootDealloc-objc-rootIsDeallocating" class="headerlink" title="8._objc_rootDealloc&#x2F;_objc_rootIsDeallocating"></a>8._objc_rootDealloc&#x2F;_objc_rootIsDeallocating</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject.mm</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_objc_rootDealloc(id obj) &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj);</span><br><span class="line">    obj-&gt;<span class="built_in">rootDealloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> </span><br><span class="line">_objc_rootIsDeallocating(id obj)  &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">rootIsDeallocating</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-object.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootDealloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(<span class="built_in">isa</span>().nonpointer                     &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().weakly_referenced             &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().has_assoc                     &amp;&amp;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ISA_HAS_CXX_DTOR_BIT</span></span><br><span class="line">                 !<span class="built_in">isa</span>().has_cxx_dtor                  &amp;&amp;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                 !<span class="built_in">isa</span>().<span class="built_in">getClass</span>(<span class="literal">false</span>)-&gt;<span class="built_in">hasCxxDtor</span>() &amp;&amp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                 !<span class="built_in">isa</span>().has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootIsDeallocating</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isa</span>().nonpointer) <span class="keyword">return</span> <span class="built_in">isa</span>().<span class="built_in">isDeallocating</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sidetable_isDeallocating</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="9-class-respondsToSelector-inst"><a href="#9-class-respondsToSelector-inst" class="headerlink" title="9.class_respondsToSelector_inst"></a>9.class_respondsToSelector_inst</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-class.mm</span></span><br><span class="line">NEVER_INLINE __attribute__((flatten)) <span class="function">BOOL</span></span><br><span class="line"><span class="function"><span class="title">class_respondsToSelector_inst</span><span class="params">(id inst, SEL sel, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Avoids +initialize because it historically did so.</span></span><br><span class="line">    <span class="comment">// We&#x27;re not returning a callable IMP anyway.</span></span><br><span class="line">    <span class="keyword">return</span> sel &amp;&amp; cls &amp;&amp; <span class="built_in">lookUpImpOrNilTryCache</span>(inst, sel, cls, LOOKUP_RESOLVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtiume-new</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrNilTryCache</span><span class="params">(id inst, SEL sel, Class cls, <span class="type">int</span> behavior)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _lookUpImpTryCache(inst, sel, cls, behavior | LOOKUP_NIL); &#123;</span><br><span class="line">        cache_getImp</span><br><span class="line">        lookUpImpOrForward &#123;</span><br><span class="line">            <span class="built_in">checkIsKnownClass</span>(cls);</span><br><span class="line">            cls = <span class="built_in">realizeAndInitializeIfNeeded_locked</span>(inst, cls, behavior &amp; LOOKUP_INITIALIZE);</span><br><span class="line">            <span class="keyword">for</span> (unreasonableClassCount, i: [start, end]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cls.cache.isConstantOptimizedCache) &#123;</span><br><span class="line">                    imp = cache_getImp <span class="comment">// ① imp缓存</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// ② 当前类查询</span></span><br><span class="line">                    <span class="type">method_t</span> *m = <span class="built_in">getMethodNoSuper_nolock</span>(cls, sel); &#123;</span><br><span class="line">                        <span class="type">method_t</span> *m = <span class="built_in">search_method_list_inline</span>(*mlists, sel); &#123;</span><br><span class="line">                            <span class="built_in">findMethodInSortedMethodList</span>() | <span class="built_in">findMethodInUnsortedMethodList</span>() &#123;</span><br><span class="line">                                <span class="built_in">findMethodInSortedMethodList</span>() &#123;</span><br><span class="line">                                    <span class="keyword">for</span>(list) -&gt; probe</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">                    <span class="comment">// ③ 父类查询</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">slowpath</span>((curClass = curClass-&gt;<span class="built_in">getSuperclass</span>()) == nil)) &#123;</span><br><span class="line">                        <span class="comment">// No implementation found, and method resolver didn&#x27;t help.</span></span><br><span class="line">                        <span class="comment">// Use forwarding.</span></span><br><span class="line">                        imp = forward_imp; <span class="comment">// ⑤ 转发</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Superclass cache.</span></span><br><span class="line">                    imp = <span class="built_in">cache_getImp</span>(curClass, sel);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">slowpath</span>(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">                    behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">resolveMethod_locked</span>(inst, sel, cls, behavior); <span class="comment">// ④ 动态方法解析</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done:</span><br><span class="line">            <span class="built_in">log_and_fill_cache</span>(cls, imp, sel, inst, curClass); <span class="comment">// 记录cache</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">                <span class="keyword">return</span> nil; <span class="comment">// 如果是转发，返回nil。表示当前类不可相应该方法</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> imp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-class-conformsToProtocol"><a href="#10-class-conformsToProtocol" class="headerlink" title="10.class_conformsToProtocol"></a>10.class_conformsToProtocol</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_conformsToProtocol</span><span class="params">(Class cls, Protocol *proto_gen)</span> </span>&#123;</span><br><span class="line">    <span class="type">protocol_t</span> *proto = <span class="built_in">newprotocol</span>(proto_gen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">if</span> (!proto_gen) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checkIsKnownClass</span>(cls);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; proto_ref : cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">protocols</span>()) &#123; <span class="comment">// 遍历protocols列表</span></span><br><span class="line">        <span class="type">protocol_t</span> *p = <span class="built_in">remapProtocol</span>(proto_ref);</span><br><span class="line">        <span class="keyword">if</span> (p == proto || <span class="built_in">protocol_conformsToProtocol_nolock</span>(p, proto)) &#123;</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="11-class-getMethodImplementation-object-getMethodImplementation"><a href="#11-class-getMethodImplementation-object-getMethodImplementation" class="headerlink" title="11.class_getMethodImplementation&#x2F;object_getMethodImplementation"></a>11.class_getMethodImplementation&#x2F;object_getMethodImplementation</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line">__attribute__((flatten))</span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL sel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls || !sel) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    IMP imp = <span class="built_in">lookUpImpOrNilTryCache</span>(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER); &#123;</span><br><span class="line">        _lookUpImpTryCache -&gt; lookUpImpOrForward</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate forwarding function to C-callable external version</span></span><br><span class="line">    <span class="keyword">if</span> (!imp) &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_msgForward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-class.mm</span></span><br><span class="line"><span class="function">IMP <span class="title">object_getMethodImplementation</span><span class="params">(id obj, SEL name)</span> </span>&#123;</span><br><span class="line">    Class cls = (obj ? obj-&gt;<span class="built_in">getIsa</span>() : nil);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">class_getMethodImplementation</span>(cls, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="12-class-getName-object-getClassName"><a href="#12-class-getName-object-getClassName" class="headerlink" title="12.class_getName&#x2F;object_getClassName"></a>12.class_getName&#x2F;object_getClassName</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">// If realize=false, the class must already be realized or future.</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">class_getName</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="string">&quot;nil&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">demangledName</span>(<span class="comment">/* needs lock */</span><span class="literal">true</span>); <span class="comment">// 后面详细分析</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-class.mm</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">object_getClassName</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">class_getName</span>(obj ? obj-&gt;<span class="built_in">getIsa</span>() : nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-object-getClass"><a href="#13-object-getClass" class="headerlink" title="13.object_getClass"></a>13.object_getClass</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-class.mm</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// objc-object.mm</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Class</span></span><br><span class="line"><span class="function"><span class="title">objc_object::getIsa</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">isTaggedPointer</span>())) <span class="keyword">return</span> <span class="built_in">ISA</span>(<span class="comment">/*authenticated*/</span><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer;</span><br><span class="line">    <span class="type">uintptr_t</span> slot, ptr = (<span class="type">uintptr_t</span>)<span class="keyword">this</span>;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    slot = (ptr &gt;&gt; _OBJC_TAG_SLOT_SHIFT) &amp; _OBJC_TAG_SLOT_MASK;</span><br><span class="line">    cls = objc_tag_classes[slot];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(cls == (Class)&amp;OBJC_CLASS_$___NSUnrecognizedTaggedPointer)) &#123;</span><br><span class="line">        slot = (ptr &gt;&gt; _OBJC_TAG_EXT_SLOT_SHIFT) &amp; _OBJC_TAG_EXT_SLOT_MASK;</span><br><span class="line">        cls = objc_tag_ext_classes[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-sel-getName"><a href="#14-sel-getName" class="headerlink" title="14.sel_getName"></a>14.sel_getName</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-sel.mm</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) <span class="keyword">return</span> <span class="string">&quot;&lt;null selector&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> *)(<span class="type">const</span> <span class="type">void</span>*)sel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-sel-registerName"><a href="#15-sel-registerName" class="headerlink" title="15.sel_registerName"></a>15.sel_registerName</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc-sel.mm</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_registerName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sel_registerName(name, <span class="number">1</span>, <span class="number">1</span>);     <span class="comment">// YES lock, YES copy</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> SEL __sel_registerName(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">bool</span> shouldLock, <span class="type">bool</span> copy) &#123;</span><br><span class="line">    SEL result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldLock) lockdebug::<span class="built_in">assert_unlocked</span>(&amp;selLock);</span><br><span class="line">    <span class="keyword">else</span>            lockdebug::<span class="built_in">assert_locked</span>(&amp;selLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!name) <span class="keyword">return</span> (SEL)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">search_builtins</span>(name); &#123;</span><br><span class="line">        <span class="function"><span class="type">static</span> SEL <span class="title">search_builtins</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> SUPPORT_PREOPT</span></span><br><span class="line">            <span class="keyword">if</span> (SEL result = (SEL)_dyld_get_objc_selector(name))</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">conditional_mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock, shouldLock)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> it = namedSelectors.<span class="built_in">get</span>().<span class="built_in">insert</span>(name);</span><br><span class="line">	<span class="keyword">if</span> (it.second) &#123;</span><br><span class="line">		<span class="comment">// No match. Insert.</span></span><br><span class="line">		*it.first = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">sel_alloc</span>(name, copy);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (SEL)*it.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h1><p>通过以上分析，问题的答案不言自明了。</p>
<h2 id="1-什么是-NSObject"><a href="#1-什么是-NSObject" class="headerlink" title="1.什么是 NSObject"></a>1.什么是 NSObject</h2><blockquote>
<p>NSObject是OC中根类，所有OC对象都是继承自NSObject。从而具有了NSObject的能力，比如消息转发、动态方法解析、与运行时交互的能力等。</p>
</blockquote>
<h2 id="2-NSObject-的本质"><a href="#2-NSObject-的本质" class="headerlink" title="2.NSObject 的本质"></a>2.NSObject 的本质</h2><blockquote>
<p>本质是结构体，运行时加载到内存中仅有一份。<br>但是它包含两个部分，一个是类对象结构体，一个是元类对象结构体，两种结构体都是objc_class – 继承自 -&gt; objc_object，为实例提供了OOP能力。<br>通过isa横向连接，串联了实例-类对象-元类对象这条链路。<br>通过superclass纵向连接，串联了继承关系链。</p>
</blockquote>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>NSObject</tag>
      </tags>
  </entry>
  <entry>
    <title>[重学技术]序章</title>
    <url>/posts/%E9%87%8D%E5%AD%A6%E6%8A%80%E6%9C%AF-%E5%BA%8F%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote>
<p>[重学技术]系列主要是针对笔者自己的能力进行的针对性学习，不代表广大读者的情况。</p>
</blockquote>
<h1 id="2-为什么开始"><a href="#2-为什么开始" class="headerlink" title="2.为什么开始"></a>2.为什么开始</h1><p>自2021年至今，真正做iOS方面的开发已经有两年有余了，但是作为移动端开发者，我把太多的时间精力关注代码质量和琐碎的业务事情上，始终没能一窥底层的面貌，对底层的理解也一直停留在了初级阶段，没有深入到底层的实现细节。我慢慢的发现，我只会在应用层实现需求。</p>
<p>总结有几点原因：其一，没有养成探索意识，觉得实现需求就够了，但事实上只完成需求远远不够。业务开发大部分是在和产品的业务逻辑、数据展现、修复Bug和用户体验等打交道，这些都需要花费大量的时间精力，以至于没时间思考，没精力探索。其二，懒于学习，不愿意花时间去学习，而是把精力放在了业务的开发上，成为了无情的<code>需求实现机</code>。其三，没有把技术的学习当作一种乐趣，而是把技术的学习当作一种痛苦，因为技术的学习是一件痛苦的事。</p>
<p>我意识到这种情况已经有一年了，但是琐事缠身或者懒癌晚期，拖到现在。人无远虑必有近忧，这话是真没错，偶然的机会开始看看外面的机会，顺便检验下自己能力。很显然结果不太好，一些基础通过复习下可以理解的还👌🏻，但是深入下去，就突然尬住，不知道该说什么。还有些问题没接触过很难回答完美，我承认是自己背诵不到位，是我菜~。所以经过几天的思考，我希望能再之后的时间提升自己的技术能力，深入底层技术，把自己训练成一个<code>技术爱好者</code>，而不是一个<code>需求实现机</code>。</p>
<p>嘀咕了这么多，我大概还需要深入理解以下内容。</p>
<h1 id="3-需要探索的底层知识"><a href="#3-需要探索的底层知识" class="headerlink" title="3.需要探索的底层知识"></a>3.需要探索的底层知识</h1><h2 id="1-iOS"><a href="#1-iOS" class="headerlink" title="1.iOS"></a>1.iOS</h2><ul>
<li>面向对象</li>
<li>内存管理</li>
<li>Runtime</li>
<li>RunLoop</li>
<li>多线程 &amp;&amp; 锁</li>
<li>网络</li>
<li>UI &amp;&amp; 渲染流水线</li>
<li>性能优化</li>
<li>文件系统 - 沙盒</li>
<li>数据库</li>
<li>第三方框架</li>
<li>Swift</li>
<li>动态链接器</li>
<li>移动端技术架构</li>
<li>逆向</li>
</ul>
<h2 id="2-计算机基础"><a href="#2-计算机基础" class="headerlink" title="2.计算机基础"></a>2.计算机基础</h2><ul>
<li>数据结构</li>
<li>算法</li>
<li>操作系统</li>
<li>编译原理</li>
<li>网络编程</li>
</ul>
<h2 id="3-编程语言"><a href="#3-编程语言" class="headerlink" title="3.编程语言"></a>3.编程语言</h2><ul>
<li>OC &amp;&amp; Swift</li>
<li>C &amp;&amp; C++</li>
<li>JS &amp;&amp; TS</li>
<li>Python</li>
<li>Java</li>
<li>Dart</li>
<li>Kotlin</li>
</ul>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><ul>
<li>设计模式</li>
<li>软件工程</li>
<li>数据库</li>
<li>图形学</li>
<li>音视频</li>
<li>浏览器</li>
<li>跨平台</li>
</ul>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>序</tag>
      </tags>
  </entry>
  <entry>
    <title>[重学技术]iOS Runloop</title>
    <url>/posts/%E9%87%8D%E5%AD%A6%E6%8A%80%E6%9C%AF-iOS-Runloop/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h1 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h1><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Runloop</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>[重学技术]iOS UI</title>
    <url>/posts/%E9%87%8D%E5%AD%A6%E6%8A%80%E6%9C%AF-iOS-UI/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h1 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h1><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>[重学技术]iOS Runtime</title>
    <url>/posts/%E9%87%8D%E5%AD%A6%E6%8A%80%E6%9C%AF-iOS-Runtime/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h1 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h1><h1 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h1><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
</search>
